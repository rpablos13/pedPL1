package compiler.syntax;

// Declaración de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

// Declaración del código de usuario

action code {:
	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();

:}	

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}
:}

// Declaración de terminales (Ejemplo)

terminal Token COMILLAS;
terminal Token OPEN_PAR;
terminal Token CLOSE_PAR;
terminal Token OPEN_CORCH;
terminal Token CLOSE_CORCH;
terminal Token OPEN_COMENT;
terminal Token CLOSE_COMENT;
terminal Token COMMA;
terminal Token PUNTO_COMA;
terminal Token DOS_PUNTOS;
terminal Token MULT;
terminal Token MINUS;
terminal Token MAYOR;
terminal Token ARRAY;
terminal Token BEGIN;
terminal Token BOOLEAN;
terminal Token CONST;
terminal Token DO;
terminal Token ELSE;
terminal Token END;
terminal Token FALSE;
terminal Token FOR;
terminal Token IF;
terminal Token INTEGER;
terminal Token MODULE;
terminal Token NOT;
terminal Token OF;
terminal Token OR;
terminal Token PROCEDURE;
terminal Token RETURN;
terminal Token THEN;
terminal Token TO;
terminal Token TRUE;
terminal Token TYPE;
terminal Token VAR;
terminal Token WRITEINT;
terminal Token WRITELN;
terminal Token WRITESTRING;
terminal Token NUM;
terminal Token STRING;
terminal Token IDEN;
terminal Token ASIGN;
terminal Token ID;
terminal Token EQUAL;
terminal Token DOT;
terminal Token ESPACIO_BLANCO;


// ...


// Declaración de no terminales
// no modificar los propuestos

non terminal  			program;
non terminal Axiom		axiom;
non terminal 			inicio;
non terminal			sentPrint;
non terminal			lambda;
non terminal			cuerpo;
non terminal 			fin;
non terminal			writeStr;
non terminal			writeL;
non terminal			writeInt;
non terminal			expr;
non terminal 			operador;
non terminal			declarVar;
non terminal			declarations;
non terminal			igualations;
non terminal			typeOfVar;
non terminal			booleans;
non terminal			operation;
non terminal			arithmeticExpr;
non terminal			asignValue;
non terminal			bodyOperations;
non terminal			intValue;
non terminal			variousOperations;
non terminal			array;
non terminal			vector;
non terminal			vectorOperation;
non terminal			simpleVector;
non terminal			endProgram;
non terminal			function;
non terminal			declarationFuntion;
non terminal			beginFunction;
non terminal			endFunction;
non terminal			initialDeclarations;
non terminal			functionReturn;
non terminal			bodyFunction;
non terminal			otherFunctionDeclarations;
non terminal			ends;
non terminal			ifCode;
non terminal			logicExpression;
non terminal			sentencesIf;
non terminal			forCode;
non terminal			finalExpression;
non terminal			sentencesFor;
non terminal			numOrIden;
non terminal			parameterFunction;
non terminal			parameters;
non terminal			callFunction;
non terminal			declarVector;
non terminal			numCharVector;
// ...


// Declaración de relaciones de precedencia
precedence left     MINUS;
// ...

// Declaración de reglas de producción


start with program;

program ::= 
  {: 
        syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
   :}
  axiom:ax
  {: 
  		// No modificar esta estructura, aunque se pueden añadir más acciones semánticas
  		// Para la entrega de febrero pueden comentarse las dos sentencias siguientes:
  		//List intermediateCode = ax.getIntermediateCode ();
  		//finalCodeFactory.create (intermediateCode);
  		// En caso de no comentarse las sentencias anteriores puede generar una excepcion
  		// en las llamadas a cupTest en la entrega de Febrero. Esto es debido a que 
  		// aún no se tendrá implementada la generación de código intermedio ni final.
  		// Para la entrega de Junio deberán descomentarse y usarse.
  		
  		syntaxErrorManager.syntaxInfo ("Parsing process ended.");
   :};

axiom::=inicio declarVar BEGIN cuerpo fin;
inicio::= MODULE IDEN PUNTO_COMA;
fin::= END IDEN PUNTO_COMA;
cuerpo::= lambda | sentPrint cuerpo | bodyOperations cuerpo | 
		  simpleVector cuerpo | numCharVector cuerpo | declarVector cuerpo |
		  ifCode cuerpo | forCode cuerpo |
		  callFunction cuerpo;

sentPrint::= writeStr | writeL | writeInt;

writeStr::= WRITESTRING OPEN_PAR STRING CLOSE_PAR PUNTO_COMA;
writeL::= WRITELN PUNTO_COMA;
writeInt::= WRITEINT OPEN_PAR intValue CLOSE_PAR PUNTO_COMA;

intValue::= NUM MINUS NUM | IDEN | simpleVector;

booleans::= TRUE | FALSE;
operation::= MULT | MINUS | MAYOR | EQUAL;
arithmeticExpr::= IDEN operation IDEN;

asignValue::= NUM | arithmeticExpr | booleans | IDEN;

bodyOperations::= IDEN igualations asignValue PUNTO_COMA | 
				  IDEN igualations OPEN_PAR IDEN OR IDEN CLOSE_PAR PUNTO_COMA | 
				  IDEN igualations IDEN OPEN_PAR IDEN COMMA IDEN CLOSE_PAR PUNTO_COMA |
				  vectorOperation;


/*****************************************************************/
/******************************VECTOR*****************************/
/*****************************************************************/
simpleVector::= IDEN OPEN_CORCH NUM CLOSE_CORCH | IDEN OPEN_CORCH IDEN CLOSE_CORCH;
numCharVector::= IDEN OPEN_CORCH NUM CLOSE_CORCH ASIGN NUM PUNTO_COMA | IDEN OPEN_CORCH IDEN CLOSE_CORCH ASIGN NUM PUNTO_COMA;
declarVector::= IDEN igualations IDEN OPEN_PAR simpleVector CLOSE_PAR PUNTO_COMA; 
vectorOperation::= IDEN OPEN_CORCH NUM CLOSE_CORCH ASIGN IDEN OPEN_CORCH NUM CLOSE_CORCH operation IDEN OPEN_CORCH IDEN OPEN_CORCH NUM CLOSE_CORCH CLOSE_CORCH operation IDEN OPEN_CORCH IDEN OPEN_CORCH IDEN OPEN_CORCH NUM CLOSE_CORCH CLOSE_CORCH CLOSE_CORCH PUNTO_COMA;

/*****************************************************************/
/******************************FUNCIONES**************************/
/*****************************************************************/
declarationFuntion::= declarations IDEN OPEN_PAR parameterFunction CLOSE_PAR PUNTO_COMA | declarations IDEN OPEN_PAR parameterFunction CLOSE_PAR igualations typeOfVar PUNTO_COMA;
beginFunction::= BEGIN cuerpo | BEGIN cuerpo RETURN IDEN PUNTO_COMA;
functionReturn::= RETURN IDEN PUNTO_COMA;
endFunction::= END IDEN PUNTO_COMA;

parameters::= IDEN igualations typeOfVar | IDEN igualations typeOfVar PUNTO_COMA;
parameterFunction::= parameters | parameters parameterFunction;

callFunction::= IDEN OPEN_PAR IDEN CLOSE_PAR PUNTO_COMA;

function::= declarationFuntion declarVar beginFunction endFunction;

/*****************************************************************/
/**********************************IF*****************************/
/*****************************************************************/
ifCode::= IF logicExpression THEN sentencesIf ELSE sentencesIf ends;
logicExpression::= IDEN operador numOrIden;
sentencesIf::= cuerpo;


/*****************************************************************/
/*********************************FOR*****************************/
/*****************************************************************/
forCode::= FOR IDEN ASIGN NUM TO finalExpression DO sentencesFor ends;
finalExpression::= NUM;
sentencesFor::= cuerpo;



declarations::= CONST | VAR | TYPE | PROCEDURE;
igualations::= DOS_PUNTOS | EQUAL | ASIGN;
typeOfVar::= NUM | INTEGER | BOOLEAN | array | IDEN;
numOrIden::= NUM | IDEN;


array::= ARRAY OPEN_CORCH NUM DOT DOT numOrIden CLOSE_CORCH OF INTEGER;
expr::= ID | NUM | expr operador expr | NOT expr;
operador::= MINUS | MULT | OR | EQUAL | MAYOR;

declarVar::=  lambda |
			  declarations IDEN igualations typeOfVar PUNTO_COMA declarVar |
			  IDEN igualations typeOfVar PUNTO_COMA declarVar|
			  function declarVar;

	
lambda::= ;
ends::= END PUNTO_COMA;

/*****************************************************************/
/*******************************ERRORES***************************/
/*****************************************************************/


